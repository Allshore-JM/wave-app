<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>Wave App</title>

    <!-- Bootstrap for layout/table -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />

    <style>
      html, body {
        height: 100%;
        margin: 0;
      }
      /* Map fills most of the viewport height */
      #map {
        width: 100%;
        height: 70vh; /* adjust if you want more/less map height */
      }
      /* Avoid a light gray flash while tiles load */
      .leaflet-container {
        background: #000;
      }
    </style>
  </head>
  <body>
    <!-- Controls -->
    <div class="container-fluid py-2">
      <form id="controls" method="POST" class="row g-2 align-items-end">
        <div class="col-sm-3 col-md-2">
          <label class="form-label" for="station">Station</label>
          <select class="form-select" name="station" id="station">
            {% for sid, name in stations %}
            <option value="{{ sid }}" {% if sid == selected_station %}selected{% endif %}>
              {{ name }}
            </option>
            {% endfor %}
          </select>
        </div>

        <div class="col-sm-4 col-md-3">
          <label class="form-label" for="tz">Time zone</label>
          <select class="form-select" name="tz" id="tz">
            <!-- Empty value means "use buoy's local timezone" on the server -->
            <option value="">(Buoy local)</option>
            {% for tz in timezones %}
            <option value="{{ tz }}" {% if tz == selected_tz %}selected{% endif %}>{{ tz }}</option>
            {% endfor %}
          </select>
        </div>

        <div class="col-sm-2 col-md-2">
          <label class="form-label" for="unit">Units</label>
          <select class="form-select" name="unit" id="unit">
            {% for u in units %}
            <option value="{{ u }}" {% if u == selected_unit %}selected{% endif %}>{{ u }}</option>
            {% endfor %}
          </select>
        </div>

        <div class="col-sm-2 col-md-2">
          <button type="submit" class="btn btn-primary w-100">Update</button>
        </div>
      </form>
    </div>

    <!-- Map -->
    <div id="map"></div>

    <!-- Table / Errors -->
    <div class="container-fluid py-3">
      {% if error %}
      <div class="alert alert-warning">{{ error }}</div>
      {% endif %}
      <div id="table-slot">
        {% if table_html %}
        {{ table_html|safe }}
        {% endif %}
      </div>
    </div>

    <!-- Leaflet JS -->
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

    <script>
      (function () {
        // ---------- One-world (no wrap) config ----------
        var WORLD_BOUNDS = L.latLngBounds([[-85, -180], [85, 180]]);
        var VIEW_KEY = "waveapp:mapView"; // localStorage key for preserving view

        var tiles = L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: "Tiles © Esri & contributors",
            noWrap: true,
            maxZoom: 19
          }
        );

        var map = L.map("map", {
          layers: [tiles],
          noWrap: true,            // single copy of the world
          worldCopyJump: false,
          maxBounds: WORLD_BOUNDS, // hard panning limit
          maxBoundsViscosity: 1.0,
          zoomControl: true
        });

        // Compute and enforce min zoom (don’t change center/zoom unless below min)
        function enforceMinZoomPreservingView() {
          var minZ = map.getBoundsZoom(WORLD_BOUNDS, true);
          map.setMinZoom(minZ);
          if (map.getZoom() < minZ) {
            map.setZoom(minZ);
          }
          map.setMaxBounds(WORLD_BOUNDS);
        }

        // Restore saved view (if any); otherwise fit world once
        function restoreViewOrFitWorld() {
          var saved = null;
          try {
            saved = JSON.parse(localStorage.getItem(VIEW_KEY) || "null");
          } catch (e) {
            saved = null;
          }
          enforceMinZoomPreservingView();
          if (
            saved &&
            saved.hasOwnProperty("lat") &&
            saved.hasOwnProperty("lng") &&
            saved.hasOwnProperty("z") &&
            isFinite(saved.lat) && isFinite(saved.lng) && isFinite(saved.z)
          ) {
            var clampedZ = Math.max(saved.z, map.getMinZoom());
            map.setView([saved.lat, saved.lng], clampedZ, { animate: false });
          } else {
            // First visit: fit world exactly to viewport, then lock min zoom.
            var minZ = map.getBoundsZoom(WORLD_BOUNDS, true);
            map.fitBounds(WORLD_BOUNDS, { padding: [0, 0] });
            map.setMinZoom(minZ);
            if (map.getZoom() < minZ) map.setZoom(minZ);
          }
        }

        restoreViewOrFitWorld();
        // Recompute min zoom only (no fit) on resize so we don't zoom out
        window.addEventListener("resize", enforceMinZoomPreservingView);

        // Persist view on user interaction
        function saveView() {
          var c = map.getCenter();
          try {
            localStorage.setItem(
              VIEW_KEY,
              JSON.stringify({ lat: c.lat, lng: c.lng, z: map.getZoom() })
            );
          } catch (e) {
            // ignore storage errors (private mode, quota, etc.)
          }
        }
        map.on("moveend", saveView);
        map.on("zoomend", saveView);

        // ---------- Station markers ----------
        var markerLayer = L.layerGroup().addTo(map);
        var formEl = document.getElementById("controls");
        var stationSel = document.getElementById("station");
        var tzSel = document.getElementById("tz");

        // When station is changed via dropdown, clear tz to "buoy local" and submit
        if (stationSel) {
          stationSel.addEventListener("change", function () {
            if (tzSel) tzSel.value = ""; // use buoy's local timezone
            if (formEl) formEl.submit();
          });
        }

        // Load stations (no cache) and attach click handlers
        function addStations(stations) {
          markerLayer.clearLayers();
          for (var i = 0; i < stations.length; i++) {
            var st = stations[i] || {};
            var lat = Number(st.lat);
            var lon = Number(st.lon);
            if (!isFinite(lat) || !isFinite(lon)) continue;

            L.circleMarker([lat, lon], {
              radius: 4,
              color: "#FFD400",
              weight: 2,
              fillColor: "#FFD400",
              fillOpacity: 1.0
            })
              .bindPopup((st.name || "Station") + " (" + (st.id || "") + ")")
              .on("click", function (e) {
                // Do NOT change the map view—just submit with tz cleared
                var marker = e.target;
                var sid = (marker && marker.getPopup())
                  ? (marker.getPopup().getContent().match(/\(([^)]+)\)$/) || [])[1]
                  : null;
                if (stationSel && sid) stationSel.value = sid;
                if (tzSel) tzSel.value = ""; // buoy local timezone
                if (formEl) formEl.submit();
              })
              .addTo(markerLayer);
          }
        }

        // Fetch stations.json with cache-busting + explicit no-store
        (function fetchStations() {
          var url = "/stations.json?_ts=" + Date.now();
          fetch(url, { cache: "no-store" })
            .then(function (r) {
              if (!r.ok) throw new Error("HTTP " + r.status);
              return r.json();
            })
            .then(function (data) {
              if (!Array.isArray(data)) throw new Error("Invalid JSON");
              addStations(data);
            })
            .catch(function (err) {
              console.error("Failed to load stations.json:", err);
              // Optional: show a banner to users
              // alert("Unable to load stations list. Please reload.");
            });
        })();

        // IMPORTANT: Do NOT auto-center to selected buoy on page load.
        // We intentionally preserve the user's previous zoom/center from localStorage.
      })();
    </script>
  </body>
</html>
